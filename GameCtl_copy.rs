// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `proto/GameCtl_copy.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct RoomListRequest {
    // message fields
    pub requirement: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoomListRequest {
    fn default() -> &'a RoomListRequest {
        <RoomListRequest as ::protobuf::Message>::default_instance()
    }
}

impl RoomListRequest {
    pub fn new() -> RoomListRequest {
        ::std::default::Default::default()
    }

    // string requirement = 1;


    pub fn get_requirement(&self) -> &str {
        &self.requirement
    }
    pub fn clear_requirement(&mut self) {
        self.requirement.clear();
    }

    // Param is passed by value, moved
    pub fn set_requirement(&mut self, v: ::std::string::String) {
        self.requirement = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requirement(&mut self) -> &mut ::std::string::String {
        &mut self.requirement
    }

    // Take field
    pub fn take_requirement(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.requirement, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RoomListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.requirement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.requirement.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.requirement);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.requirement.is_empty() {
            os.write_string(1, &self.requirement)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoomListRequest {
        RoomListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "requirement",
                    |m: &RoomListRequest| { &m.requirement },
                    |m: &mut RoomListRequest| { &mut m.requirement },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoomListRequest>(
                    "RoomListRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoomListRequest {
        static mut instance: ::protobuf::lazy::Lazy<RoomListRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoomListRequest,
        };
        unsafe {
            instance.get(RoomListRequest::new)
        }
    }
}

impl ::protobuf::Clear for RoomListRequest {
    fn clear(&mut self) {
        self.requirement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoomListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoomListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoomListResponse {
    // message fields
    pub result: ::protobuf::RepeatedField<Room>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoomListResponse {
    fn default() -> &'a RoomListResponse {
        <RoomListResponse as ::protobuf::Message>::default_instance()
    }
}

impl RoomListResponse {
    pub fn new() -> RoomListResponse {
        ::std::default::Default::default()
    }

    // repeated .RoomStatus.Room result = 1;


    pub fn get_result(&self) -> &[Room] {
        &self.result
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::protobuf::RepeatedField<Room>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    pub fn mut_result(&mut self) -> &mut ::protobuf::RepeatedField<Room> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::protobuf::RepeatedField<Room> {
        ::std::mem::replace(&mut self.result, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RoomListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.result {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.result {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoomListResponse {
        RoomListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Room>>(
                    "result",
                    |m: &RoomListResponse| { &m.result },
                    |m: &mut RoomListResponse| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoomListResponse>(
                    "RoomListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoomListResponse {
        static mut instance: ::protobuf::lazy::Lazy<RoomListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoomListResponse,
        };
        unsafe {
            instance.get(RoomListResponse::new)
        }
    }
}

impl ::protobuf::Clear for RoomListResponse {
    fn clear(&mut self) {
        self.result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoomListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoomListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoomCreateRequest {
    // message fields
    pub HostId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoomCreateRequest {
    fn default() -> &'a RoomCreateRequest {
        <RoomCreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl RoomCreateRequest {
    pub fn new() -> RoomCreateRequest {
        ::std::default::Default::default()
    }

    // string HostId = 1;


    pub fn get_HostId(&self) -> &str {
        &self.HostId
    }
    pub fn clear_HostId(&mut self) {
        self.HostId.clear();
    }

    // Param is passed by value, moved
    pub fn set_HostId(&mut self, v: ::std::string::String) {
        self.HostId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HostId(&mut self) -> &mut ::std::string::String {
        &mut self.HostId
    }

    // Take field
    pub fn take_HostId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.HostId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RoomCreateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.HostId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.HostId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.HostId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.HostId.is_empty() {
            os.write_string(1, &self.HostId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoomCreateRequest {
        RoomCreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "HostId",
                    |m: &RoomCreateRequest| { &m.HostId },
                    |m: &mut RoomCreateRequest| { &mut m.HostId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoomCreateRequest>(
                    "RoomCreateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoomCreateRequest {
        static mut instance: ::protobuf::lazy::Lazy<RoomCreateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoomCreateRequest,
        };
        unsafe {
            instance.get(RoomCreateRequest::new)
        }
    }
}

impl ::protobuf::Clear for RoomCreateRequest {
    fn clear(&mut self) {
        self.HostId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoomCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoomCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoomRequest {
    // message fields
    pub key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoomRequest {
    fn default() -> &'a RoomRequest {
        <RoomRequest as ::protobuf::Message>::default_instance()
    }
}

impl RoomRequest {
    pub fn new() -> RoomRequest {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RoomRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoomRequest {
        RoomRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &RoomRequest| { &m.key },
                    |m: &mut RoomRequest| { &mut m.key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoomRequest>(
                    "RoomRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoomRequest {
        static mut instance: ::protobuf::lazy::Lazy<RoomRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoomRequest,
        };
        unsafe {
            instance.get(RoomRequest::new)
        }
    }
}

impl ::protobuf::Clear for RoomRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoomRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoomRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Room {
    // message fields
    pub key: ::std::string::String,
    pub host_id: ::std::string::String,
    pub dueler_id: ::std::string::String,
    pub status: Status,
    pub round: i32,
    pub cell: i32,
    pub cell_status: ::protobuf::RepeatedField<CellStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Room {
    fn default() -> &'a Room {
        <Room as ::protobuf::Message>::default_instance()
    }
}

impl Room {
    pub fn new() -> Room {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string host_id = 2;


    pub fn get_host_id(&self) -> &str {
        &self.host_id
    }
    pub fn clear_host_id(&mut self) {
        self.host_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_id(&mut self, v: ::std::string::String) {
        self.host_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_id(&mut self) -> &mut ::std::string::String {
        &mut self.host_id
    }

    // Take field
    pub fn take_host_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host_id, ::std::string::String::new())
    }

    // string dueler_id = 3;


    pub fn get_dueler_id(&self) -> &str {
        &self.dueler_id
    }
    pub fn clear_dueler_id(&mut self) {
        self.dueler_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dueler_id(&mut self, v: ::std::string::String) {
        self.dueler_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dueler_id(&mut self) -> &mut ::std::string::String {
        &mut self.dueler_id
    }

    // Take field
    pub fn take_dueler_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dueler_id, ::std::string::String::new())
    }

    // .RoomStatus.Status status = 4;


    pub fn get_status(&self) -> Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Status::ON_START;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = v;
    }

    // int32 round = 5;


    pub fn get_round(&self) -> i32 {
        self.round
    }
    pub fn clear_round(&mut self) {
        self.round = 0;
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i32) {
        self.round = v;
    }

    // int32 cell = 6;


    pub fn get_cell(&self) -> i32 {
        self.cell
    }
    pub fn clear_cell(&mut self) {
        self.cell = 0;
    }

    // Param is passed by value, moved
    pub fn set_cell(&mut self, v: i32) {
        self.cell = v;
    }

    // repeated .RoomStatus.CellStatus cell_status = 7;


    pub fn get_cell_status(&self) -> &[CellStatus] {
        &self.cell_status
    }
    pub fn clear_cell_status(&mut self) {
        self.cell_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_cell_status(&mut self, v: ::protobuf::RepeatedField<CellStatus>) {
        self.cell_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cell_status(&mut self) -> &mut ::protobuf::RepeatedField<CellStatus> {
        &mut self.cell_status
    }

    // Take field
    pub fn take_cell_status(&mut self) -> ::protobuf::RepeatedField<CellStatus> {
        ::std::mem::replace(&mut self.cell_status, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Room {
    fn is_initialized(&self) -> bool {
        for v in &self.cell_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dueler_id)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.round = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cell = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cell_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.host_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.host_id);
        }
        if !self.dueler_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.dueler_id);
        }
        if self.status != Status::ON_START {
            my_size += ::protobuf::rt::enum_size(4, self.status);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::value_size(5, self.round, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cell != 0 {
            my_size += ::protobuf::rt::value_size(6, self.cell, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.cell_status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.host_id.is_empty() {
            os.write_string(2, &self.host_id)?;
        }
        if !self.dueler_id.is_empty() {
            os.write_string(3, &self.dueler_id)?;
        }
        if self.status != Status::ON_START {
            os.write_enum(4, self.status.value())?;
        }
        if self.round != 0 {
            os.write_int32(5, self.round)?;
        }
        if self.cell != 0 {
            os.write_int32(6, self.cell)?;
        }
        for v in &self.cell_status {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Room {
        Room::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &Room| { &m.key },
                    |m: &mut Room| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host_id",
                    |m: &Room| { &m.host_id },
                    |m: &mut Room| { &mut m.host_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dueler_id",
                    |m: &Room| { &m.dueler_id },
                    |m: &mut Room| { &mut m.dueler_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                    "status",
                    |m: &Room| { &m.status },
                    |m: &mut Room| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "round",
                    |m: &Room| { &m.round },
                    |m: &mut Room| { &mut m.round },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "cell",
                    |m: &Room| { &m.cell },
                    |m: &mut Room| { &mut m.cell },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CellStatus>>(
                    "cell_status",
                    |m: &Room| { &m.cell_status },
                    |m: &mut Room| { &mut m.cell_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Room>(
                    "Room",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Room {
        static mut instance: ::protobuf::lazy::Lazy<Room> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Room,
        };
        unsafe {
            instance.get(Room::new)
        }
    }
}

impl ::protobuf::Clear for Room {
    fn clear(&mut self) {
        self.key.clear();
        self.host_id.clear();
        self.dueler_id.clear();
        self.status = Status::ON_START;
        self.round = 0;
        self.cell = 0;
        self.cell_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Room {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Room {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CellStatus {
    // message fields
    pub key: ::std::string::String,
    pub turn: i32,
    pub cell_num: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CellStatus {
    fn default() -> &'a CellStatus {
        <CellStatus as ::protobuf::Message>::default_instance()
    }
}

impl CellStatus {
    pub fn new() -> CellStatus {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // int32 turn = 2;


    pub fn get_turn(&self) -> i32 {
        self.turn
    }
    pub fn clear_turn(&mut self) {
        self.turn = 0;
    }

    // Param is passed by value, moved
    pub fn set_turn(&mut self, v: i32) {
        self.turn = v;
    }

    // int32 cell_num = 3;


    pub fn get_cell_num(&self) -> i32 {
        self.cell_num
    }
    pub fn clear_cell_num(&mut self) {
        self.cell_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_cell_num(&mut self, v: i32) {
        self.cell_num = v;
    }
}

impl ::protobuf::Message for CellStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.turn = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.cell_num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if self.turn != 0 {
            my_size += ::protobuf::rt::value_size(2, self.turn, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cell_num != 0 {
            my_size += ::protobuf::rt::value_size(3, self.cell_num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if self.turn != 0 {
            os.write_int32(2, self.turn)?;
        }
        if self.cell_num != 0 {
            os.write_int32(3, self.cell_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CellStatus {
        CellStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    |m: &CellStatus| { &m.key },
                    |m: &mut CellStatus| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "turn",
                    |m: &CellStatus| { &m.turn },
                    |m: &mut CellStatus| { &mut m.turn },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "cell_num",
                    |m: &CellStatus| { &m.cell_num },
                    |m: &mut CellStatus| { &mut m.cell_num },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CellStatus>(
                    "CellStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CellStatus {
        static mut instance: ::protobuf::lazy::Lazy<CellStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CellStatus,
        };
        unsafe {
            instance.get(CellStatus::new)
        }
    }
}

impl ::protobuf::Clear for CellStatus {
    fn clear(&mut self) {
        self.key.clear();
        self.turn = 0;
        self.cell_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CellStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CellStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Empty {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Empty {
    fn default() -> &'a Empty {
        <Empty as ::protobuf::Message>::default_instance()
    }
}

impl Empty {
    pub fn new() -> Empty {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Empty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Empty {
        Empty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Empty>(
                    "Empty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Empty {
        static mut instance: ::protobuf::lazy::Lazy<Empty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Empty,
        };
        unsafe {
            instance.get(Empty::new)
        }
    }
}

impl ::protobuf::Clear for Empty {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Empty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateCredReq {
    // message fields
    pub Ip: ::std::string::String,
    pub Username: ::std::string::String,
    pub Password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateCredReq {
    fn default() -> &'a CreateCredReq {
        <CreateCredReq as ::protobuf::Message>::default_instance()
    }
}

impl CreateCredReq {
    pub fn new() -> CreateCredReq {
        ::std::default::Default::default()
    }

    // string Ip = 1;


    pub fn get_Ip(&self) -> &str {
        &self.Ip
    }
    pub fn clear_Ip(&mut self) {
        self.Ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ip(&mut self, v: ::std::string::String) {
        self.Ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Ip(&mut self) -> &mut ::std::string::String {
        &mut self.Ip
    }

    // Take field
    pub fn take_Ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Ip, ::std::string::String::new())
    }

    // string Username = 2;


    pub fn get_Username(&self) -> &str {
        &self.Username
    }
    pub fn clear_Username(&mut self) {
        self.Username.clear();
    }

    // Param is passed by value, moved
    pub fn set_Username(&mut self, v: ::std::string::String) {
        self.Username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Username(&mut self) -> &mut ::std::string::String {
        &mut self.Username
    }

    // Take field
    pub fn take_Username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Username, ::std::string::String::new())
    }

    // string Password = 3;


    pub fn get_Password(&self) -> &str {
        &self.Password
    }
    pub fn clear_Password(&mut self) {
        self.Password.clear();
    }

    // Param is passed by value, moved
    pub fn set_Password(&mut self, v: ::std::string::String) {
        self.Password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Password(&mut self) -> &mut ::std::string::String {
        &mut self.Password
    }

    // Take field
    pub fn take_Password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateCredReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Ip)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Ip.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Ip);
        }
        if !self.Username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Username);
        }
        if !self.Password.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Ip.is_empty() {
            os.write_string(1, &self.Ip)?;
        }
        if !self.Username.is_empty() {
            os.write_string(2, &self.Username)?;
        }
        if !self.Password.is_empty() {
            os.write_string(3, &self.Password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateCredReq {
        CreateCredReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Ip",
                    |m: &CreateCredReq| { &m.Ip },
                    |m: &mut CreateCredReq| { &mut m.Ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Username",
                    |m: &CreateCredReq| { &m.Username },
                    |m: &mut CreateCredReq| { &mut m.Username },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "Password",
                    |m: &CreateCredReq| { &m.Password },
                    |m: &mut CreateCredReq| { &mut m.Password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateCredReq>(
                    "CreateCredReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateCredReq {
        static mut instance: ::protobuf::lazy::Lazy<CreateCredReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateCredReq,
        };
        unsafe {
            instance.get(CreateCredReq::new)
        }
    }
}

impl ::protobuf::Clear for CreateCredReq {
    fn clear(&mut self) {
        self.Ip.clear();
        self.Username.clear();
        self.Password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateCredReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateCredReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cred {
    // message fields
    pub file: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cred {
    fn default() -> &'a Cred {
        <Cred as ::protobuf::Message>::default_instance()
    }
}

impl Cred {
    pub fn new() -> Cred {
        ::std::default::Default::default()
    }

    // string file = 1;


    pub fn get_file(&self) -> &str {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Cred {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cred {
        Cred::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file",
                    |m: &Cred| { &m.file },
                    |m: &mut Cred| { &mut m.file },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Cred>(
                    "Cred",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Cred {
        static mut instance: ::protobuf::lazy::Lazy<Cred> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Cred,
        };
        unsafe {
            instance.get(Cred::new)
        }
    }
}

impl ::protobuf::Clear for Cred {
    fn clear(&mut self) {
        self.file.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cred {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cred {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Status {
    ON_START = 0,
    ON_WAIT = 1,
    ON_HOST_TURN = 2,
    ON_DUEL_TURN = 3,
    ON_END = 4,
}

impl ::protobuf::ProtobufEnum for Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            0 => ::std::option::Option::Some(Status::ON_START),
            1 => ::std::option::Option::Some(Status::ON_WAIT),
            2 => ::std::option::Option::Some(Status::ON_HOST_TURN),
            3 => ::std::option::Option::Some(Status::ON_DUEL_TURN),
            4 => ::std::option::Option::Some(Status::ON_END),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Status] = &[
            Status::ON_START,
            Status::ON_WAIT,
            Status::ON_HOST_TURN,
            Status::ON_DUEL_TURN,
            Status::ON_END,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Status", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Status {
}

impl ::std::default::Default for Status {
    fn default() -> Self {
        Status::ON_START
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x18proto/GameCtl_copy.proto\x12\nRoomStatus\"3\n\x0fRoomListRequest\
    \x12\x20\n\x0brequirement\x18\x01\x20\x01(\tR\x0brequirement\"<\n\x10Roo\
    mListResponse\x12(\n\x06result\x18\x01\x20\x03(\x0b2\x10.RoomStatus.Room\
    R\x06result\"+\n\x11RoomCreateRequest\x12\x16\n\x06HostId\x18\x01\x20\
    \x01(\tR\x06HostId\"\x1f\n\x0bRoomRequest\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\"\xdd\x01\n\x04Room\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x17\n\x07host_id\x18\x02\x20\x01(\tR\x06hostId\x12\x1b\n\tdu\
    eler_id\x18\x03\x20\x01(\tR\x08duelerId\x12*\n\x06status\x18\x04\x20\x01\
    (\x0e2\x12.RoomStatus.StatusR\x06status\x12\x14\n\x05round\x18\x05\x20\
    \x01(\x05R\x05round\x12\x12\n\x04cell\x18\x06\x20\x01(\x05R\x04cell\x127\
    \n\x0bcell_status\x18\x07\x20\x03(\x0b2\x16.RoomStatus.CellStatusR\ncell\
    Status\"M\n\nCellStatus\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x12\n\x04turn\x18\x02\x20\x01(\x05R\x04turn\x12\x19\n\x08cell_num\x18\
    \x03\x20\x01(\x05R\x07cellNum\"\x07\n\x05Empty\"W\n\rCreateCredReq\x12\
    \x0e\n\x02Ip\x18\x01\x20\x01(\tR\x02Ip\x12\x1a\n\x08Username\x18\x02\x20\
    \x01(\tR\x08Username\x12\x1a\n\x08Password\x18\x03\x20\x01(\tR\x08Passwo\
    rd\"\x1a\n\x04Cred\x12\x12\n\x04file\x18\x01\x20\x01(\tR\x04file*S\n\x06\
    Status\x12\x0c\n\x08ON_START\x10\0\x12\x0b\n\x07ON_WAIT\x10\x01\x12\x10\
    \n\x0cON_HOST_TURN\x10\x02\x12\x10\n\x0cON_DUEL_TURN\x10\x03\x12\n\n\x06\
    ON_END\x10\x042\x91\x03\n\nRoomStatus\x12?\n\nCreateRoom\x12\x1d.RoomSta\
    tus.RoomCreateRequest\x1a\x10.RoomStatus.Room\"\0\x12J\n\x0bGetRoomList\
    \x12\x1b.RoomStatus.RoomListRequest\x1a\x1c.RoomStatus.RoomListResponse\
    \"\0\x12:\n\x0bGetRoomInfo\x12\x17.RoomStatus.RoomRequest\x1a\x10.RoomSt\
    atus.Room\"\0\x12:\n\nDeleteRoom\x12\x17.RoomStatus.RoomRequest\x1a\x11.\
    RoomStatus.Empty\"\0\x12>\n\nUpdateRoom\x12\x16.RoomStatus.CellStatus\
    \x1a\x16.RoomStatus.CellStatus\"\0\x12>\n\x08QuitRoom\x12\x1d.RoomStatus\
    .RoomCreateRequest\x1a\x11.RoomStatus.Empty\"\02L\n\x0bCreditsAuth\x12=\
    \n\nCreateCred\x12\x19.RoomStatus.CreateCredReq\x1a\x10.RoomStatus.Cred\
    \"\00\x01B\x1aZ\x05proto\xaa\x02\x10PlayCli.ProtoModJ\xa4\x20\n\x07\x12\
    \x05\x01\0\x94\x01\x01\n\x9e\x02\n\x01\x0c\x12\x03\x01\0\x12\x1a\x0f\x20\
    #\x20hello.proto\n\"\x82\x02\x20import\x20\"google/protobuf/empty.proto\
    \";\n\x20import\x20\"google/api/annotations.proto\";\n\x20import\x20\"pr\
    otoc-gen-swagger/options/annotations.proto\";\n\x20import\x20\"github.co\
    m/gogo/protobuf/gogoproto/gogo.proto\";\n\x20import\x20\"github.com/mwit\
    kow/go-proto-validators/validator.proto\";\n\n\x08\n\x01\x02\x12\x03\x08\
    \0\x13\n\x08\n\x01\x08\x12\x03\t\0-\n\t\n\x02\x08%\x12\x03\t\0-\n\x08\n\
    \x01\x08\x12\x03\n\0\x1d\n\xfc\x05\n\x02\x08\x0b\x12\x03\n\0\x1d\"\xf0\
    \x05\x20option\x20(grpc.gateway.protoc_gen_swagger.options.openapiv2_swa\
    gger)\x20=\x20{\n\x20\x20\x20info:\x20{\n\x20\x20\x20\x20\x20version:\
    \x20\"0.1\";\n\x20\x20\x20};\n\x20\x20\x20external_docs:\x20{\n\x20\x20\
    \x20\x20\x20url:\x20\"https://github.com/stvchm9703/IDCT\";\n\x20\x20\
    \x20\x20\x20description:\x20\"gRPC\x20server\x20Impletement\x20repositor\
    y\";\n\x20\x20\x20}\n\x20\x20\x20schemes:\x20HTTPS;\n\x20};\n\x20//\x20E\
    nable\x20custom\x20Marshal\x20method.\n\x20option\x20(gogoproto.marshale\
    r_all)\x20=\x20true;\n\x20//\x20Enable\x20custom\x20Unmarshal\x20method.\
    \n\x20option\x20(gogoproto.unmarshaler_all)\x20=\x20true;\n\x20//\x20Ena\
    ble\x20custom\x20Size\x20method\x20(Required\x20by\x20Marshal\x20and\x20\
    Unmarshal).\n\x20option\x20(gogoproto.sizer_all)\x20=\x20true;\n\x20//\
    \x20Enable\x20registration\x20with\x20golang/protobuf\x20for\x20the\x20g\
    rpc-gateway.\n\x20option\x20(gogoproto.goproto_registration)\x20=\x20tru\
    e;\n\x20//\x20Enable\x20generation\x20of\x20XXX_MessageName\x20methods\
    \x20for\x20grpc-go/status.\n\x20option\x20(gogoproto.messagename_all)\
    \x20=\x20true;\n\n\x97\x01\n\x02\x04\0\x12\x04)\0+\x012\x8a\x01\x20messa\
    ge\x20CreateCredReq\x20{\n\x20\x20\x20\x20\x20string\x20Ip\x20=1;\n\x20\
    \x20\x20\x20\x20string\x20Username\x20=\x202;\n\x20\x20\x20\x20\x20strin\
    g\x20Password\x20=3;\n\x20}\n\x20message\x20Cred{\n\x20\x20\x20\x20\x20s\
    tring\x20file\x20=\x201;\n\x20}\n\n\n\n\x03\x04\0\x01\x12\x03)\x08\x17\n\
    \x0b\n\x04\x04\0\x02\0\x12\x03*\x04\x1b\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03*\x04\n\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03*\x0b\x16\n\x0c\n\x05\x04\
    \0\x02\0\x03\x12\x03*\x19\x1a\n\n\n\x02\x04\x01\x12\x04-\0/\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03-\x08\x18\n\x0b\n\x04\x04\x01\x02\0\x12\x03.\x04\
    \x1d\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03.\x04\x0c\n\x0c\n\x05\x04\x01\
    \x02\0\x06\x12\x03.\r\x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03.\x12\x18\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03.\x1b\x1c\n\n\n\x02\x04\x02\x12\
    \x040\02\x01\n\n\n\x03\x04\x02\x01\x12\x030\x08\x19\n\x0b\n\x04\x04\x02\
    \x02\0\x12\x031\x04\x16\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x031\x04\n\n\
    \x0c\n\x05\x04\x02\x02\0\x01\x12\x031\x0b\x11\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x031\x14\x15\n\n\n\x02\x04\x03\x12\x043\05\x01\n\n\n\x03\x04\
    \x03\x01\x12\x033\x08\x13\n\x0b\n\x04\x04\x03\x02\0\x12\x034\x04\x13\n\
    \x0c\n\x05\x04\x03\x02\0\x05\x12\x034\x04\n\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x034\x0b\x0e\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x034\x11\x12\n\n\
    \n\x02\x05\0\x12\x046\0<\x01\n\n\n\x03\x05\0\x01\x12\x036\x05\x0b\n\x0b\
    \n\x04\x05\0\x02\0\x12\x037\x04\x11\n\x0c\n\x05\x05\0\x02\0\x01\x12\x037\
    \x04\x0c\n\x0c\n\x05\x05\0\x02\0\x02\x12\x037\x0f\x10\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x038\x04\x11\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x038\x04\x0b\
    \n\x0c\n\x05\x05\0\x02\x01\x02\x12\x038\x0e\x0f\n\x0b\n\x04\x05\0\x02\
    \x02\x12\x039\x04\x15\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x039\x04\x10\n\
    \x0c\n\x05\x05\0\x02\x02\x02\x12\x039\x13\x14\n\x0b\n\x04\x05\0\x02\x03\
    \x12\x03:\x04\x15\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03:\x04\x10\n\x0c\n\
    \x05\x05\0\x02\x03\x02\x12\x03:\x13\x14\n\x0b\n\x04\x05\0\x02\x04\x12\
    \x03;\x04\x0f\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03;\x04\n\n\x0c\n\x05\
    \x05\0\x02\x04\x02\x12\x03;\r\x0e\n\n\n\x02\x04\x04\x12\x04=\0E\x01\n\n\
    \n\x03\x04\x04\x01\x12\x03=\x08\x0c\n\x0b\n\x04\x04\x04\x02\0\x12\x03>\
    \x04\x13\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03>\x04\n\n\x0c\n\x05\x04\
    \x04\x02\0\x01\x12\x03>\x0b\x0e\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03>\
    \x11\x12\n\x0b\n\x04\x04\x04\x02\x01\x12\x03?\x04\x17\n\x0c\n\x05\x04\
    \x04\x02\x01\x05\x12\x03?\x04\n\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03?\
    \x0b\x12\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03?\x15\x16\n\x0b\n\x04\
    \x04\x04\x02\x02\x12\x03@\x04\x19\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\
    \x03@\x04\n\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03@\x0b\x14\n\x0c\n\x05\
    \x04\x04\x02\x02\x03\x12\x03@\x17\x18\n\x0b\n\x04\x04\x04\x02\x03\x12\
    \x03A\x04\x16\n\x0c\n\x05\x04\x04\x02\x03\x06\x12\x03A\x04\n\n\x0c\n\x05\
    \x04\x04\x02\x03\x01\x12\x03A\x0b\x11\n\x0c\n\x05\x04\x04\x02\x03\x03\
    \x12\x03A\x14\x15\n\x0b\n\x04\x04\x04\x02\x04\x12\x03B\x04\x14\n\x0c\n\
    \x05\x04\x04\x02\x04\x05\x12\x03B\x04\t\n\x0c\n\x05\x04\x04\x02\x04\x01\
    \x12\x03B\n\x0f\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03B\x12\x13\n\x0b\n\
    \x04\x04\x04\x02\x05\x12\x03C\x04\x13\n\x0c\n\x05\x04\x04\x02\x05\x05\
    \x12\x03C\x04\t\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x03C\n\x0e\n\x0c\n\
    \x05\x04\x04\x02\x05\x03\x12\x03C\x11\x12\n\x0b\n\x04\x04\x04\x02\x06\
    \x12\x03D\x04(\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\x03D\x04\x0c\n\x0c\n\
    \x05\x04\x04\x02\x06\x06\x12\x03D\r\x17\n\x0c\n\x05\x04\x04\x02\x06\x01\
    \x12\x03D\x18#\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03D&'\n\n\n\x02\x04\
    \x05\x12\x04G\0K\x01\n\n\n\x03\x04\x05\x01\x12\x03G\x08\x12\n\x0b\n\x04\
    \x04\x05\x02\0\x12\x03H\x04\x13\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03H\
    \x04\n\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03H\x0b\x0e\n\x0c\n\x05\x04\
    \x05\x02\0\x03\x12\x03H\x11\x12\n(\n\x04\x04\x05\x02\x01\x12\x03I\x04\
    \x13\"\x1b\x20turn\x201\x20=\x20host\x20/\x20-1\x20=\x20duel\n\n\x0c\n\
    \x05\x04\x05\x02\x01\x05\x12\x03I\x04\t\n\x0c\n\x05\x04\x05\x02\x01\x01\
    \x12\x03I\n\x0e\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03I\x11\x12\n\x0b\n\
    \x04\x04\x05\x02\x02\x12\x03J\x04\x17\n\x0c\n\x05\x04\x05\x02\x02\x05\
    \x12\x03J\x04\t\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03J\n\x12\n\x0c\n\
    \x05\x04\x05\x02\x02\x03\x12\x03J\x15\x16\n\t\n\x02\x04\x06\x12\x03L\0\
    \x0f\n\n\n\x03\x04\x06\x01\x12\x03L\x08\r\n\x0b\n\x02\x06\0\x12\x05M\0\
    \x81\x01\x01\n\n\n\x03\x06\0\x01\x12\x03M\x08\x12\n^\n\x04\x06\0\x02\0\
    \x12\x04N\x04S\x05\"P\x20option\x20(google.api.http)\x20=\x20{\n\x20\x20\
    \x20\x20\x20post:\x20\"/v1/room/create\"\n\x20\x20\x20\x20\x20body:\x20\
    \"*\"\n\x20};\x20\x20\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03N\x08\x12\n\
    \x0c\n\x05\x06\0\x02\0\x02\x12\x03N\x14%\n\x0c\n\x05\x06\0\x02\0\x03\x12\
    \x03N04\n[\n\x04\x06\0\x02\x01\x12\x04T\x04Y\x05\"M\x20option\x20(google\
    .api.http)\x20=\x20{\n\x20\x20\x20\x20\x20post:\x20\"/v1/room/list\"\n\
    \x20\x20\x20\x20\x20body:\x20\"*\"\n\x20};\x20\n\n\x0c\n\x05\x06\0\x02\
    \x01\x01\x12\x03T\x08\x13\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03T\x14#\n\
    \x0c\n\x05\x06\0\x02\x01\x03\x12\x03T.>\n[\n\x04\x06\0\x02\x02\x12\x04Z\
    \x04_\x05\"M\x20option\x20(google.api.http)\x20=\x20{\n\x20\x20\x20\x20\
    \x20post:\x20\"/v1/room/info\"\n\x20\x20\x20\x20\x20body:\x20\"*\"\n\x20\
    };\x20\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03Z\x08\x13\n\x0c\n\x05\x06\
    \0\x02\x02\x02\x12\x03Z\x15\x20\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03Z+/\
    \n]\n\x04\x06\0\x02\x03\x12\x04`\x04e\x05\"O\x20option\x20(google.api.ht\
    tp)\x20=\x20{\n\x20\x20\x20\x20\x20post:\x20\"/v1/room/delete\"\n\x20\
    \x20\x20\x20\x20body:\x20\"*\"\n\x20};\x20\n\n\x0c\n\x05\x06\0\x02\x03\
    \x01\x12\x03`\x08\x12\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03`\x14\x1f\n\
    \x0c\n\x05\x06\0\x02\x03\x03\x12\x03`*/\n\xb2\x03\n\x04\x06\0\x02\x04\
    \x12\x04s\x04x\x05\x1a\xd2\x02\x20rpc\x20GetRoomStream\x20(RoomRequest)\
    \x20returns\x20(stream\x20CellStatus){\n\x20\x20\x20\x20\x20option\x20(g\
    oogle.api.http)\x20=\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20post:\x20\
    \"/v1/room/stream\"\n\x20\x20\x20\x20\x20\x20\x20\x20\x20body:\x20\"*\"\
    \n\x20\x20\x20\x20\x20};\x20\n\x20};\n\x20rpc\x20UpdateRoomStream(stream\
    \x20CellStatus)\x20returns\x20\x20(stream\x20CellStatus){\n\x20\x20\x20\
    \x20\x20option\x20(google.api.http)\x20=\x20{\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20post:\x20\"/v1/room/stream/update\"\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20body:\x20\"*\"\n\x20\x20\x20\x20\x20};\x20\n\x20};\n\"O\
    \x20option\x20(google.api.http)\x20=\x20{\n\x20\x20\x20\x20\x20post:\x20\
    \"/v1/room/update\"\n\x20\x20\x20\x20\x20body:\x20\"*\"\n\x20};\x20\n\n\
    \x0c\n\x05\x06\0\x02\x04\x01\x12\x03s\x08\x12\n\x0c\n\x05\x06\0\x02\x04\
    \x02\x12\x03s\x14\x1e\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03s)3\n\\\n\x04\
    \x06\0\x02\x05\x12\x04z\x04\x7f\x05\"N\x20\x20option\x20(google.api.http\
    )\x20=\x20{\n\x20\x20\x20\x20\x20post:\x20\"/v1/room/quit\"\n\x20\x20\
    \x20\x20\x20body:\x20\"*\"\n\x20};\x20\n\n\x0c\n\x05\x06\0\x02\x05\x01\
    \x12\x03z\x08\x10\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03z\x11\"\n\x0c\n\
    \x05\x06\0\x02\x05\x03\x12\x03z,1\n\x0c\n\x02\x04\x07\x12\x06\x83\x01\0\
    \x87\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x83\x01\x08\x15\n\x0c\n\x04\
    \x04\x07\x02\0\x12\x04\x84\x01\x04\x11\n\r\n\x05\x04\x07\x02\0\x05\x12\
    \x04\x84\x01\x04\n\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\x84\x01\x0b\r\n\r\
    \n\x05\x04\x07\x02\0\x03\x12\x04\x84\x01\x0f\x10\n\x0c\n\x04\x04\x07\x02\
    \x01\x12\x04\x85\x01\x04\x18\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\x85\
    \x01\x04\n\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x85\x01\x0b\x13\n\r\n\
    \x05\x04\x07\x02\x01\x03\x12\x04\x85\x01\x16\x17\n\x0c\n\x04\x04\x07\x02\
    \x02\x12\x04\x86\x01\x04\x17\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\x86\
    \x01\x04\n\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\x86\x01\x0b\x13\n\r\n\
    \x05\x04\x07\x02\x02\x03\x12\x04\x86\x01\x15\x16\n\x0c\n\x02\x04\x08\x12\
    \x06\x89\x01\0\x8b\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\x89\x01\x08\
    \x0c\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x8a\x01\x04\x14\n\r\n\x05\x04\x08\
    \x02\0\x05\x12\x04\x8a\x01\x04\n\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x8a\
    \x01\x0b\x0f\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x8a\x01\x12\x13\n\x0c\n\
    \x02\x06\x01\x12\x06\x8d\x01\0\x94\x01\x01\n\x0b\n\x03\x06\x01\x01\x12\
    \x04\x8d\x01\x08\x13\na\n\x04\x06\x01\x02\0\x12\x06\x8e\x01\x04\x93\x01\
    \x05\"Q\x20\x20option\x20(google.api.http)\x20=\x20{\n\x20\x20\x20\x20\
    \x20post:\x20\"/v1/cred/create\"\n\x20\x20\x20\x20\x20body:\x20\"*\"\n\
    \x20};\x20\x20\n\n\r\n\x05\x06\x01\x02\0\x01\x12\x04\x8e\x01\x08\x12\n\r\
    \n\x05\x06\x01\x02\0\x02\x12\x04\x8e\x01\x14!\n\r\n\x05\x06\x01\x02\0\
    \x06\x12\x04\x8e\x01,2\n\r\n\x05\x06\x01\x02\0\x03\x12\x04\x8e\x0137b\
    \x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
